<html>
<head>
    <title>Grok Snowfight</title>
    <style>
        canvas { 
            border: 1px solid black; 
            width: 100%; 
            height: auto; 
            max-width: 600px; 
            touch-action: manipulation; 
        }
        #controls {
            margin: 10px auto;
            max-width: 600px;
            padding: 10px;
            text-align: center;
            font-size: 16px;
        }
        .dial {
            width: 100px;
            height: 100px;
            background: conic-gradient(#ddd, #ddd 0deg, #00f 0deg, #00f 360deg);
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            margin: 10px auto;
            touch-action: none;
        }
        .dial .inner {
            width: 80px;
            height: 80px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .dial .handle {
            width: 10px;
            height: 30px;
            background: #00f;
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: bottom;
            transition: transform 0.1s;
        }
        button {
            padding: 8px 16px;
            font-size: 16px;
            margin: 5px;
            touch-action: manipulation;
        }
        @media (max-width: 600px) {
            #controls {
                font-size: 14px;
            }
            .dial {
                width: 80px;
                height: 80px;
            }
            .dial .inner {
                width: 64px;
                height: 64px;
                font-size: 12px;
            }
            button {
                padding: 6px 12px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <div id="controls">
        <label for="angle">Angle (0-90):</label>
        <input type="number" id="angle" min="0" max="90" value="45" oninput="updateAim()">
        <div class="dial" id="powerDial">
            <div class="inner">Power: <span id="powerValue">50</span></div>
            <div class="handle" id="powerHandle"></div>
        </div>
        <label for="ammo">Ammo:</label>
        <select id="ammo">
            <option value="snowball">Snowball</option>
            <option value="frost_bomb">Frost Bomb</option>
        </select>
        <button id="loadButton">Load Snow</button>
        <button id="fireButton">Fire</button>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerPos = { x: 100, y: 350 };
        const aiPos = { x: 500, y: 350 };
        const size = 40;
        const g = 0.2;
        let health = { player: 100, ai: 100 };
        let isPlayerTurn = true;
        let animationFrameId = null;
        let hitEffect = { target: null, time: 0 };
        let aimPoint = { x: 0, y: 0 };
        let ammo = { player: 10, ai: 10 };
        let snowballSize = { player: 0, ai: 0 };
        let maxSnowballSize = 100;
        let iceBlocks = [];
        let centralWall = { x: 280, y: 150, width: 40, height: 200, health: 100 };
        let power = 50; // Initial power for dial

        // Initialize ice blocks
        function initIceBlocks() {
            iceBlocks = [];
            for (let i = 0; i < 3; i++) {
                const width = 20 + Math.random() * 40;
                const height = 10 + Math.random() * 20;
                const x = 150 + Math.random() * 300;
                const y = 50 + Math.random() * 200;
                iceBlocks.push({ x, y, width, height, health: width * 1 });
            }
        }

        // Draw the scene
        function drawScene() {
            // Responsive canvas scaling
            const scale = Math.min(canvas.width / 600, canvas.height / 400);
            ctx.scale(scale, scale);
            ctx.clearRect(0, 0, 600, 400);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 350, 600, 50);

            // Draw player and AI
            ctx.fillStyle = hitEffect.target === 'player' && hitEffect.time > 0 ? 'red' : 'blue';
            ctx.beginPath();
            ctx.arc(playerPos.x, playerPos.y - size/2, size/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = hitEffect.target === 'ai' && hitEffect.time > 0 ? 'red' : 'orange';
            ctx.beginPath();
            ctx.arc(aiPos.x, aiPos.y - size/2, size/2, 0, Math.PI * 2);
            ctx.fill();

            // Draw health bars
            ctx.fillStyle = 'green';
            ctx.fillRect(playerPos.x - 20, playerPos.y - size - 10, health.player / 2, 5);
            ctx.fillRect(aiPos.x - 20, aiPos.y - size - 10, health.ai / 2, 5);

            // Draw snow piles
            ctx.fillStyle = 'lightgray';
            ctx.fillRect(playerPos.x - 30, playerPos.y, 20, -ammo.player * 2);
            ctx.fillRect(aiPos.x + 10, aiPos.y, 20, -ammo.ai * 2);

            // Draw central wall
            if (centralWall.health > 0) {
                ctx.fillStyle = 'lightblue';
                ctx.fillRect(centralWall.x, centralWall.y, centralWall.width, centralWall.height);
            }

            // Draw ice blocks
            iceBlocks.forEach(block => {
                if (block.health > 0) {
                    ctx.fillStyle = 'lightblue';
                    ctx.fillRect(block.x - block.width/2, block.y - block.height/2, block.width, block.height);
                }
            });

            // Draw aiming point
            if (isPlayerTurn && !animationFrameId) {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(aimPoint.x, aimPoint.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset scale
        }

        // Update aiming point (halved radius to 100px)
        function updateAim() {
            if (!isPlayerTurn || animationFrameId) return;
            const angle = parseInt(document.getElementById('angle').value) * Math.PI / 180;
            const radius = 100; // Halved from 200px
            let x = playerPos.x + radius * Math.cos(angle);
            let y = playerPos.y - size/2 - radius * Math.sin(angle);

            // Check collision with central wall
            if (centralWall.health > 0 && x >= centralWall.x && x <= centralWall.x + centralWall.width &&
                y >= centralWall.y && y <= centralWall.y + centralWall.height) {
                x = centralWall.x + (x > centralWall.x + centralWall.width/2 ? centralWall.width : 0);
                y = centralWall.y + centralWall.height;
            }

            // Check collision with ice blocks
            for (let block of iceBlocks) {
                if (block.health > 0 && x >= block.x - block.width/2 && x <= block.x + block.width/2 &&
                    y >= block.y - block.height/2 && y <= block.y + block.height/2) {
                    x = block.x + (x > block.x ? block.width/2 : -block.width/2);
                    y = block.y + block.height/2;
                    break;
                }
            }

            aimPoint = { x, y };
            drawScene();
        }

        // Power dial control
        const dial = document.getElementById('powerDial');
        const handle = document.getElementById('powerHandle');
        const powerValue = document.getElementById('powerValue');
        let isDragging = false;

        function updatePowerDial(e) {
            if (!isDragging) return;
            const rect = dial.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            angle = (angle < 0) ? angle + 360 : angle;
            power = Math.round((angle / 360) * 100);
            if (power < 0) power = 0;
            if (power > 100) power = 100;
            const rotate = `rotate(${(power / 100) * 360 - 90}deg)`;
            handle.style.transform = rotate + ` translate(-50%, 0)`;
            powerValue.textContent = power;
            updateAim();
        }

        dial.addEventListener('mousedown', () => isDragging = true);
        dial.addEventListener('touchstart', (e) => { e.preventDefault(); isDragging = true; }, { passive: false });
        document.addEventListener('mousemove', updatePowerDial);
        document.addEventListener('touchmove', (e) => updatePowerDial(e.touches[0]), { passive: false });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('touchend', () => isDragging = false);

        // Animate projectile
        function animateProjectile(startX, startY, angle, power, ammo, targetX, callback) {
            let t = 0;
            const v = power / 10;
            const theta = angle * Math.PI / 180;
            const vx = v * Math.cos(theta);
            const vyInitial = v * Math.sin(theta);
            const sizeFactor = snowballSize[isPlayerTurn ? 'player' : 'ai'] / maxSnowballSize;

            function step() {
                t += 0.1 * (1 + sizeFactor);
                const x = startX + vx * t / (1 + sizeFactor);
                const y = startY - (vyInitial * t - 0.5 * g * t * t);
                drawScene();

                ctx.fillStyle = ammo === 'snowball' ? 'gray' : 'cyan';
                ctx.strokeStyle = 'black';
                const radius = 5 + sizeFactor * 10;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                if (centralWall.health > 0 && x >= centralWall.x && x <= centralWall.x + centralWall.width &&
                    y >= centralWall.y && y <= centralWall.y + centralWall.height) {
                    centralWall.health -= ammo === 'snowball' ? 10 : 20;
                    centralWall.height = centralWall.health * 2;
                    if (centralWall.health <= 0) centralWall.health = 0;
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    callback(false);
                    return;
                }

                for (let block of iceBlocks) {
                    if (block.health > 0 && x >= block.x - block.width/2 && x <= block.x + block.width/2 &&
                        y >= block.y - block.height/2 && y <= block.y + block.height/2) {
                        block.health -= ammo === 'snowball' ? 10 : 20;
                        if (block.health <= 0) block.health = 0;
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                        callback(false);
                        return;
                    }
                }

                if (Math.abs(x - targetX) < size && y > 350 - size && y < 350) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    callback(true);
                } else if (x > 600 || x < 0 || y > 400) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    callback(false);
                } else {
                    animationFrameId = requestAnimationFrame(step);
                }
            }
            animationFrameId = requestAnimationFrame(step);
        }

        // Hit effect
        function triggerHitEffect(target) {
            hitEffect = { target, time: 10 };
            const shake = setInterval(() => {
                hitEffect.time--;
                drawScene();
                if (hitEffect.time <= 0) clearInterval(shake);
            }, 50);
        }

        // Load snow
        function loadSnow(player) {
            if (ammo[player] > 0 && snowballSize[player] < maxSnowballSize) {
                ammo[player]--;
                snowballSize[player] += 20;
                if (snowballSize[player] > maxSnowballSize) snowballSize[player] = maxSnowballSize;
                drawScene();
            }
        }

        // AI turn
        function aiTurn() {
            setTimeout(() => {
                let angle = Math.random() * 30 + 30;
                let power = Math.random() * 40 + 40;
                if (aiLastMissed) {
                    angle += Math.random() * 10 - 5;
                    power += Math.random() * 10 - 5;
                }
                angle = Math.min(90, Math.max(0, angle));
                power = Math.min(100, Math.max(1, power));

                if (ammo.ai > 0 && snowballSize.ai === 0) loadSnow('ai');
                if (snowballSize.ai > 0) {
                    animateProjectile(aiPos.x, aiPos.y - size/2, angle, power, Math.random() > 0.3 ? 'snowball' : 'frost_bomb', playerPos.x, (hit) => {
                        if (hit) {
                            health.player -= (10 + snowballSize.ai / 5);
                            triggerHitEffect('player');
                            snowballSize.ai = 0;
                            aiLastMissed = false;
                        } else {
                            snowballSize.ai = 0;
                            aiLastMissed = true;
                        }
                        checkGameOver();
                        isPlayerTurn = true;
                        drawScene();
                        updateAim();
                    });
                } else {
                    isPlayerTurn = true;
                    updateAim();
                }
            }, 1000);
        }

        let aiLastMissed = false;

        // Game over check
        function checkGameOver() {
            if (health.player <= 0) {
                alert('Grok’s AI wins!');
                resetGame();
            } else if (health.ai <= 0) {
                alert('You win Grok Snowfight!');
                resetGame();
            }
        }

        // Reset game
        function resetGame() {
            health = { player: 100, ai: 100 };
            ammo = { player: 10, ai: 10 };
            snowballSize = { player: 0, ai: 0 };
            centralWall = { x: 280, y: 150, width: 40, height: 200, health: 100 };
            initIceBlocks();
            isPlayerTurn = true;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            drawScene();
            updateAim();
        }

        // Event listeners
        document.getElementById('loadButton').addEventListener('click', () => {
            if (isPlayerTurn && !animationFrameId) loadSnow('player');
        });

        document.getElementById('fireButton').addEventListener('click', () => {
            if (!isPlayerTurn || animationFrameId || snowballSize.player === 0) return;
            const angle = parseInt(document.getElementById('angle').value);
            const ammoType = document.getElementById('ammo').value;

            animateProjectile(playerPos.x, playerPos.y - size/2, angle, power, ammoType, aiPos.x, (hit) => {
                if (hit) {
                    health.ai -= (10 + snowballSize.player / 5);
                    triggerHitEffect('ai');
                    snowballSize.player = 0;
                } else {
                    snowballSize.player = 0;
                }
                checkGameOver();
                if (health.ai > 0) {
                    isPlayerTurn = false;
                    aiTurn();
                } else {
                    isPlayerTurn = true;
                    updateAim();
                }
            });
        });

        initIceBlocks();
        drawScene();
        updateAim();
    </script>
</body>
</html>